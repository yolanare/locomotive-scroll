{"version":3,"file":"locomotive-scroll.modern.mjs","sources":["../core/IO.ts","../utils/maths.ts","../core/ScrollElement.ts","../core/Core.ts","../core/RO.ts","../index.ts"],"sourcesContent":["/**\r\n * Intersection Observer\r\n *\r\n * Detecting visibility of an element in the viewport.\r\n *\r\n * Features functions to:\r\n *\r\n * - Trigger inview/outOfView callbacks\r\n * - If the element has a requestAnimationFrame dependency, set interactivy status for the ScrollElement Class\r\n *\r\n * References:\r\n *\r\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API}\r\n */\r\n\r\nimport type { IIOOptions } from '../types';\r\nimport ScrollElement from './ScrollElement';\r\n\r\nexport default class IO {\r\n    public scrollElements: ScrollElement[];\r\n    private rootMargin: string;\r\n    private IORaf: boolean;\r\n    private observer!: IntersectionObserver;\r\n\r\n    constructor({\r\n        scrollElements,\r\n        rootMargin = '-1px -1px -1px -1px',\r\n        IORaf,\r\n    }: IIOOptions) {\r\n        // Parameters\r\n        this.scrollElements = scrollElements;\r\n        this.rootMargin = rootMargin;\r\n        this.IORaf = IORaf;\r\n\r\n        // Init\r\n        this._init();\r\n    }\r\n\r\n    /**\r\n     * Lifecyle - Initialize Intersection Observer.\r\n     *\r\n     * @private\r\n     */\r\n    private _init() {\r\n        // Options\r\n        const observerOptions = {\r\n            rootMargin: this.rootMargin,\r\n        };\r\n\r\n        // Callback\r\n        const onIntersect = (entries: IntersectionObserverEntry[]) => {\r\n            entries.forEach((entry) => {\r\n                const $targetItem: ScrollElement | undefined =\r\n                    this.scrollElements.find(\r\n                        (item) => item.$el === entry.target\r\n                    );\r\n\r\n                if (entry.isIntersecting) {\r\n                    $targetItem && ($targetItem.isAlreadyIntersected = true);\r\n                    this._setInview(entry);\r\n                } else if ($targetItem && $targetItem.isAlreadyIntersected) {\r\n                    this._setOutOfView(entry);\r\n                }\r\n            });\r\n        };\r\n\r\n        // Instance\r\n        this.observer = new IntersectionObserver(onIntersect, observerOptions);\r\n\r\n        // Observe each default elements\r\n        for (const scrollElement of this.scrollElements) {\r\n            const $scrollElement = scrollElement.$el;\r\n            this.observe($scrollElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lifecyle - Destroy Intersection Observer.\r\n     */\r\n    public destroy() {\r\n        this.observer.disconnect();\r\n    }\r\n\r\n    /**\r\n     * Subscribe element to the Intersection Observer.\r\n     *\r\n     * @param {HTMLElement} $scrollElement - DOM Element to observe.\r\n     */\r\n    public observe($scrollElement: HTMLElement) {\r\n        if (!$scrollElement) {\r\n            return;\r\n        }\r\n\r\n        this.observer.observe($scrollElement);\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe element to the Intersection Observer.\r\n     *\r\n     * @param {HTMLElement} $scrollElement - DOM Element to unobserve.\r\n     */\r\n    public unobserve($scrollElement: HTMLElement) {\r\n        if (!$scrollElement) {\r\n            return;\r\n        }\r\n\r\n        this.observer.unobserve($scrollElement);\r\n    }\r\n\r\n    /**\r\n     * Find ScrollElementReference instance and trigger inview callbacks.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\r\n     */\r\n    private _setInview(entry: IntersectionObserverEntry) {\r\n        const scrollElement = this.scrollElements.find(\r\n            (scrollElement) => scrollElement.$el === entry.target\r\n        );\r\n\r\n        this.IORaf && scrollElement?.setInteractivityOn();\r\n        !this.IORaf && scrollElement?.setInview();\r\n    }\r\n\r\n    /**\r\n     * Find ScrollElementReference instance and trigger out of view callbacks.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\r\n     */\r\n    private _setOutOfView(entry: IntersectionObserverEntry) {\r\n        const scrollElement = this.scrollElements.find(\r\n            (scrollElement) => scrollElement.$el === entry.target\r\n        );\r\n\r\n        this.IORaf && scrollElement?.setInteractivityOff();\r\n        !this.IORaf && scrollElement?.setOutOfView();\r\n\r\n        // Unobserve if element doesn't have repeat attribute\r\n        if (!scrollElement?.attributes.scrollRepeat && !this.IORaf) {\r\n            this.unobserve(entry.target as HTMLElement);\r\n        }\r\n    }\r\n}\r\n","// https://greensock.com/docs/v3/GSAP/gsap.utils\r\n\r\n/**\r\n * Clamp a value to fit within a specific range (ex: clamp(0, 100, -12) --> 0).\r\n *\r\n * @param {number} min   - Minimum value expected.\r\n * @param {number} max   - Maximum value expected.\r\n * @param {number} value - Current value.\r\n *\r\n * @returns {number} - Clamped value.\r\n */\r\nexport function clamp(min: number, max: number, value: number): number {\r\n    return value < min ? min : value > max ? max : value;\r\n}\r\n\r\n/**\r\n * Map one range to another (ex: mapRange(-10, 10, 0, 100, 5) --> 75).\r\n *\r\n * @param {number} inMin  - Current minimum value.\r\n * @param {number} inMax  - Current maximum value.\r\n * @param {number} outMin - Maximum value expected.\r\n * @param {number} outMax - Maximum value expected.\r\n * @param {number} value  - Current value.\r\n *\r\n * @returns {number} - New value that should be between minimum value expected and maximum value.\r\n */\r\nexport function mapRange(\r\n    inMin: number,\r\n    inMax: number,\r\n    outMin: number,\r\n    outMax: number,\r\n    value: number\r\n): number {\r\n    const inRange = inMax - inMin;\r\n    const outRange = outMax - outMin;\r\n    return outMin + (((value - inMin) / inRange) * outRange || 0);\r\n}\r\n\r\n/**\r\n * Map a number within a range to a progress between 0 to 1 (ex: normalize(100, 200, 150) --> 0.5).\r\n *\r\n * @param {number} min   - Current minimum value.\r\n * @param {number} max   - Current maximum value.\r\n * @param {number} value - Current value.\r\n *\r\n * @returns {number} - New value that should be between 0 and 1.\r\n */\r\nexport function normalize(min: number, max: number, value: number): number {\r\n    return mapRange(min, max, 0, 1, value);\r\n}\r\n\r\n/**\r\n * Get closest number from an array.\r\n *\r\n * @param {number[]} array  - Numbers array.\r\n * @param {number}   target - Reference value.\r\n *\r\n * @returns {number} - Closest number.\r\n */\r\nexport function closestNumber(array: number[], target: number): number {\r\n    return array.reduce((prev, curr) => {\r\n        return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;\r\n    });\r\n}\r\n","/**\r\n * Scroll Element\r\n *\r\n * Give tools to compute element progress in the viewport and triggers callbacks to animate it.\r\n *\r\n * Features functions to:\r\n *\r\n * - scrollClass - Add a custom class when the element is intersected by the offset\r\n * - scrollOffset - Determine offsets to intersect the element\r\n * - scrollPosition - Determine the element positions to consider an element as intersected.\r\n * - scrollModuleProgress - Send scroll progress to modular module that have a specific method (PROGRESS_MODULAR_METHOD)\r\n * - scrollCssProgress - Add a specific css variable (PROGRESS_CSS_VAR) that store the scroll progress\r\n * - scrollEventProgress - Send scroll progress to custom event listeners.\r\n * - scrollSpeed - Add a scroll multiplicator to create a parallax effect\r\n * + scrollParallaxSideways - Translates the scroll parallax direction to be sideways from the scroll orientation.\r\n * + scrollParallaxClamp - Clamps the scroll parallax to the origin position of the element, negative or positive (-/+).\r\n * - scrollRepeat - Repeat the option to trigger animation each time the element is intersected\r\n * - scrollCall - Call a custom event or a modular callback when the element is intersected\r\n */\r\n\r\nimport type {\r\n    IModular,\r\n    IScrollElementOptions,\r\n    IScrollElementAttributes,\r\n    IScrollElementIntersection,\r\n    IScrollElementMetrics,\r\n    IProgressModularModules,\r\n    IScrollElementCallbacksValues,\r\n    scrollCallWay,\r\n    scrollCallFrom,\r\n    scrollOrientation,\r\n} from '../types';\r\nimport { clamp, closestNumber, normalize, mapRange } from '../utils/maths';\r\n\r\n/** Constants */\r\nconst INVIEW_CLASS = 'is-inview';\r\nconst PROGRESS_CSS_VAR = '--progress';\r\nconst PROGRESS_MODULAR_METHOD = 'onScrollProgress';\r\n\r\nexport default class ScrollElement {\r\n    public $el: HTMLElement;\r\n    public id: number;\r\n    public needRaf: boolean;\r\n    public attributes: IScrollElementAttributes;\r\n    public scrollOrientation: scrollOrientation;\r\n    public isAlreadyIntersected: boolean;\r\n\r\n    private intersection: IScrollElementIntersection;\r\n    private metrics: IScrollElementMetrics;\r\n    private currentScroll: number;\r\n    private translateValue: number;\r\n    private progress: number;\r\n    private lastProgress: number | null;\r\n    private modularInstance?: IModular;\r\n    private progressModularModules: IProgressModularModules[];\r\n    private isInview: boolean;\r\n    private isInteractive: boolean;\r\n    private isInFold: boolean;\r\n    private isFirstResize: boolean;\r\n\r\n    private subscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\r\n    private unsubscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\r\n\r\n    constructor({\r\n        $el,\r\n        id,\r\n        modularInstance,\r\n        subscribeElementUpdateFn,\r\n        unsubscribeElementUpdateFn,\r\n        needRaf,\r\n        scrollOrientation,\r\n    }: IScrollElementOptions) {\r\n        // Scroll DOM element\r\n        this.$el = $el;\r\n        // Unique ID\r\n        this.id = id;\r\n        // RAF option\r\n        this.needRaf = needRaf;\r\n        // Scroll Direction\r\n        this.scrollOrientation = scrollOrientation;\r\n        // Modular.js\r\n        this.modularInstance = modularInstance;\r\n        // Parent's callbacks\r\n        this.subscribeElementUpdateFn = subscribeElementUpdateFn;\r\n        this.unsubscribeElementUpdateFn = unsubscribeElementUpdateFn;\r\n\r\n        // Attributes\r\n        this.attributes = {\r\n            scrollClass: this.$el.dataset['scrollClass'] ?? INVIEW_CLASS,\r\n            scrollOffset: this.$el.dataset['scrollOffset'] ?? '0,0',\r\n            scrollPosition: this.$el.dataset['scrollPosition'] ?? 'start,end',\r\n            scrollModuleProgress:\r\n                this.$el.dataset['scrollModuleProgress'] != null,\r\n            scrollCssProgress: this.$el.dataset['scrollCssProgress'] != null,\r\n            scrollEventProgress:\r\n                this.$el.dataset['scrollEventProgress'] ?? null,\r\n            scrollSpeed:\r\n                this.$el.dataset['scrollSpeed'] != null\r\n                    ? parseFloat(this.$el.dataset['scrollSpeed'])\r\n                    : null,\r\n            scrollParallaxSideways: this.$el.dataset['scrollParallaxSideways'] != null,\r\n            scrollParallaxClamp: this.$el.dataset['scrollParallaxClamp'] ?? null,\r\n            scrollRepeat: this.$el.dataset['scrollRepeat'] != null,\r\n            scrollCall: this.$el.dataset['scrollCall'] ?? null,\r\n            scrollCallSelf: this.$el.dataset['scrollCallSelf'] != null,\r\n            scrollIgnoreFold: this.$el.dataset['scrollIgnoreFold'] != null,\r\n            scrollEnableTouchSpeed:\r\n                this.$el.dataset['scrollEnableTouchSpeed'] != null,\r\n        };\r\n\r\n        // Limits\r\n        this.intersection = {\r\n            start: 0,\r\n            end: 0,\r\n        };\r\n\r\n        // Metrics\r\n        this.metrics = {\r\n            offsetStart: 0,\r\n            offsetEnd: 0,\r\n            bcr: {} as DOMRect,\r\n        };\r\n\r\n        // Scroll Values\r\n        this.currentScroll =\r\n            this.scrollOrientation === 'vertical'\r\n                ? window.scrollY\r\n                : window.scrollX;\r\n\r\n        // Parallax\r\n        this.translateValue = 0;\r\n\r\n        // Progress\r\n        this.progress = 0;\r\n        this.lastProgress = null;\r\n        this.progressModularModules = [];\r\n\r\n        // Inview\r\n        this.isInview = false;\r\n        this.isInteractive = false;\r\n        this.isAlreadyIntersected = false;\r\n        this.isInFold = false;\r\n        this.isFirstResize = true;\r\n\r\n        // Init\r\n        this._init();\r\n    }\r\n\r\n    /**\r\n     * Lifecyle - Initialize progress tracking.\r\n     *\r\n     * @private\r\n     */\r\n    private _init() {\r\n        if (!this.needRaf) {\r\n            return;\r\n        }\r\n\r\n        // Prepare modules progress\r\n        if (this.modularInstance && this.attributes.scrollModuleProgress) {\r\n            this._getProgressModularModules();\r\n        }\r\n\r\n        // First resize to compute all values\r\n        this._resize();\r\n    }\r\n\r\n    /**\r\n     * Callback - Resize callback\r\n     */\r\n    public onResize({ currentScroll }: IScrollElementCallbacksValues) {\r\n        this.currentScroll = currentScroll;\r\n        this._resize();\r\n    }\r\n\r\n    /**\r\n     * Callback - RAF callback\r\n     */\r\n    public onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\r\n        const wSize =\r\n            this.scrollOrientation === 'vertical'\r\n                ? window.innerHeight\r\n                : window.innerWidth;\r\n        this.currentScroll = currentScroll;\r\n        this._computeProgress();\r\n\r\n        // Parallax\r\n        if (\r\n            this.attributes.scrollSpeed &&\r\n            !isNaN(this.attributes.scrollSpeed)\r\n        ) {\r\n            // if touch detected or smooth disabled\r\n            if (!this.attributes.scrollEnableTouchSpeed && !smooth) {\r\n                if (this.translateValue) {\r\n                    this.$el.style.transform = `translate3d(0, 0, 0)`;\r\n                }\r\n                this.translateValue = 0;\r\n\r\n                // if mousewheel or smooth enabled\r\n            } else {\r\n                // Check fold condition\r\n                if (this.isInFold) {\r\n                    const progress = Math.max(0, this.progress);\r\n                    this.translateValue =\r\n                        progress * wSize * this.attributes.scrollSpeed * -1;\r\n                } else {\r\n                    let progress = mapRange(0, 1, -1, 1, this.progress);\r\n\r\n                    switch (this.attributes.scrollParallaxClamp) {\r\n                        case '+':\r\n                            progress = Math.max(progress, 0);\r\n                            break;\r\n\r\n                        case '-':\r\n                            progress = Math.min(progress, 0);\r\n                            break;\r\n                    }\r\n\r\n                    this.translateValue =\r\n                        progress * wSize * this.attributes.scrollSpeed * -1;\r\n                }\r\n\r\n                this.$el.style.transform = `translate3d(${\r\n                    this.scrollOrientation === 'vertical'\r\n                        ? this.attributes.scrollParallaxSideways\r\n                            ? `${this.translateValue}px, 0`\r\n                            : `0, ${this.translateValue}px`\r\n                        : this.attributes.scrollParallaxSideways\r\n                            ? `0, ${this.translateValue}px`\r\n                            : `${this.translateValue}px, 0`\r\n                }, 0)`;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inview callback\r\n     */\r\n    public setInview() {\r\n        if (this.isInview) {\r\n            return;\r\n        }\r\n\r\n        this.isInview = true;\r\n        this.$el.classList.add(this.attributes.scrollClass);\r\n\r\n        const way: scrollCallWay = 'enter';\r\n        const from: scrollCallFrom = this._getScrollCallFrom();\r\n        this.attributes.scrollCall && this._dispatchCall(way, from);\r\n    }\r\n\r\n    /**\r\n     * Out of view callback\r\n     */\r\n    public setOutOfView() {\r\n        if (!(this.isInview && this.attributes.scrollRepeat)) {\r\n            return;\r\n        }\r\n\r\n        this.isInview = false;\r\n        this.$el.classList.remove(this.attributes.scrollClass);\r\n\r\n        const way: scrollCallWay = 'leave';\r\n        const from: scrollCallFrom = this._getScrollCallFrom();\r\n        this.attributes.scrollCall && this._dispatchCall(way, from);\r\n    }\r\n\r\n    /**\r\n     * Switch interactivity on to subscribe the instance to the RAF\r\n     * and start calculations.\r\n     */\r\n    public setInteractivityOn() {\r\n        if (this.isInteractive) {\r\n            return;\r\n        }\r\n\r\n        this.isInteractive = true;\r\n        this.subscribeElementUpdateFn(this);\r\n    }\r\n\r\n    /**\r\n     * Switch interactivity off to unsubscribe the instance to the RAF\r\n     * and stop calculations.\r\n     */\r\n    public setInteractivityOff() {\r\n        if (!this.isInteractive) {\r\n            return;\r\n        }\r\n\r\n        this.isInteractive = false;\r\n        this.unsubscribeElementUpdateFn(this);\r\n\r\n        // Force progress to progress limit when the element is out\r\n        this.lastProgress != null &&\r\n            this._computeProgress(closestNumber([0, 1], this.lastProgress));\r\n    }\r\n\r\n    /**\r\n     * Resize method that compute the element's values.\r\n     *\r\n     * @private\r\n     */\r\n    private _resize() {\r\n        this.metrics.bcr = this.$el.getBoundingClientRect();\r\n        this._computeMetrics();\r\n        this._computeIntersection();\r\n\r\n        // First resize logic\r\n        if (this.isFirstResize) {\r\n            this.isFirstResize = false;\r\n            // Dispatch default call if the element is in fold.\r\n            if (this.isInFold) {\r\n                this.setInview();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute element's offsets and determine if the element is in fold.\r\n     *\r\n     * @private\r\n     */\r\n    private _computeMetrics() {\r\n        const { top, left, height, width } = this.metrics.bcr;\r\n        const wSize =\r\n            this.scrollOrientation === 'vertical'\r\n                ? window.innerHeight\r\n                : window.innerWidth;\r\n        const metricsStart = this.scrollOrientation === 'vertical' ? top : left;\r\n        const metricsSize =\r\n            this.scrollOrientation === 'vertical' ? height : width;\r\n\r\n        this.metrics.offsetStart =\r\n            this.currentScroll + metricsStart - this.translateValue;\r\n        this.metrics.offsetEnd = this.metrics.offsetStart + metricsSize;\r\n\r\n        if (\r\n            this.metrics.offsetStart < wSize &&\r\n            !this.attributes.scrollIgnoreFold\r\n        ) {\r\n            this.isInFold = true;\r\n        } else {\r\n            this.isInFold = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute intersection values depending on the context.\r\n     *\r\n     * @private\r\n     */\r\n    private _computeIntersection() {\r\n        // Window size\r\n        const wSize =\r\n            this.scrollOrientation === 'vertical'\r\n                ? window.innerHeight\r\n                : window.innerWidth;\r\n\r\n        // Metrics size\r\n        const metricsSize =\r\n            this.scrollOrientation === 'vertical'\r\n                ? this.metrics.bcr.height\r\n                : this.metrics.bcr.width;\r\n\r\n        // Offset\r\n        const offset = this.attributes.scrollOffset.split(',');\r\n        const offsetStart = offset[0] != undefined ? offset[0].trim() : '0';\r\n        const offsetEnd = offset[1] != undefined ? offset[1].trim() : '0';\r\n\r\n        // Positions\r\n        const scrollPosition = this.attributes.scrollPosition.split(',');\r\n        let scrollPositionStart =\r\n            scrollPosition[0] != undefined ? scrollPosition[0].trim() : 'start';\r\n        const scrollPositionEnd =\r\n            scrollPosition[1] != undefined ? scrollPosition[1].trim() : 'end';\r\n\r\n        // Viewport\r\n        const viewportStart = offsetStart.includes('%')\r\n            ? wSize * parseInt(offsetStart.replace('%', '').trim()) * 0.01\r\n            : parseInt(offsetStart);\r\n        const viewportEnd = offsetEnd.includes('%')\r\n            ? wSize * parseInt(offsetEnd.replace('%', '').trim()) * 0.01\r\n            : parseInt(offsetEnd);\r\n\r\n        // Fold exception\r\n        if (this.isInFold) {\r\n            scrollPositionStart = 'fold';\r\n        }\r\n\r\n        // Define Intersection Start\r\n        switch (scrollPositionStart) {\r\n            case 'start':\r\n                this.intersection.start =\r\n                    this.metrics.offsetStart - wSize + viewportStart;\r\n                break;\r\n\r\n            case 'middle':\r\n                this.intersection.start =\r\n                    this.metrics.offsetStart -\r\n                    wSize +\r\n                    viewportStart +\r\n                    metricsSize * 0.5;\r\n                break;\r\n\r\n            case 'end':\r\n                this.intersection.start =\r\n                    this.metrics.offsetStart -\r\n                    wSize +\r\n                    viewportStart +\r\n                    metricsSize;\r\n                break;\r\n\r\n            case 'fold':\r\n                this.intersection.start = 0;\r\n                break;\r\n\r\n            default:\r\n                this.intersection.start =\r\n                    this.metrics.offsetStart - wSize + viewportStart;\r\n                break;\r\n        }\r\n\r\n        // Define Intersection End\r\n        switch (scrollPositionEnd) {\r\n            case 'start':\r\n                this.intersection.end = this.metrics.offsetStart - viewportEnd;\r\n                break;\r\n\r\n            case 'middle':\r\n                this.intersection.end =\r\n                    this.metrics.offsetStart - viewportEnd + metricsSize * 0.5;\r\n                break;\r\n\r\n            case 'end':\r\n                this.intersection.end =\r\n                    this.metrics.offsetStart - viewportEnd + metricsSize;\r\n                break;\r\n\r\n            default:\r\n                this.intersection.end =\r\n                    this.metrics.offsetStart - viewportEnd + metricsSize;\r\n                break;\r\n        }\r\n\r\n        // Avoid to have the end < the start intersection >\r\n        if (this.intersection.end <= this.intersection.start) {\r\n            switch (scrollPositionEnd) {\r\n                case 'start':\r\n                    this.intersection.end = this.intersection.start + 1;\r\n                    break;\r\n\r\n                case 'middle':\r\n                    this.intersection.end =\r\n                        this.intersection.start + metricsSize * 0.5;\r\n                    break;\r\n\r\n                case 'end':\r\n                    this.intersection.end =\r\n                        this.intersection.start + metricsSize;\r\n                    break;\r\n\r\n                default:\r\n                    this.intersection.end = this.intersection.start + 1;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute the scroll progress of the element depending\r\n     * on its intersection values.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {number} [forcedProgress] - Value to force progress.\r\n     */\r\n    private _computeProgress(forcedProgress?: number) {\r\n        // Progress\r\n        const progress =\r\n            forcedProgress ??\r\n            clamp(\r\n                0,\r\n                1,\r\n                normalize(\r\n                    this.intersection.start,\r\n                    this.intersection.end,\r\n                    this.currentScroll\r\n                )\r\n            );\r\n\r\n        this.progress = progress;\r\n\r\n        if (progress != this.lastProgress) {\r\n            this.lastProgress = progress;\r\n\r\n            // Set the element's progress to the css variable\r\n            this.attributes.scrollCssProgress && this._setCssProgress(progress);\r\n\r\n            // Set the element's progress to the custom event listeners\r\n            this.attributes.scrollEventProgress &&\r\n                this._setCustomEventProgress(progress);\r\n\r\n            // Set the element's progress to inline modules\r\n            if (this.attributes.scrollModuleProgress) {\r\n                for (const modularModules of this.progressModularModules) {\r\n                    this.modularInstance &&\r\n                        this.modularInstance.call(\r\n                            PROGRESS_MODULAR_METHOD,\r\n                            progress,\r\n                            modularModules.moduleName,\r\n                            modularModules.moduleId\r\n                        );\r\n                }\r\n            }\r\n\r\n            // Logic to trigger the inview/out of view callbacks\r\n            progress > 0 && progress < 1 && this.setInview();\r\n            progress === 0 && this.setOutOfView();\r\n            progress === 1 && this.setOutOfView();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the element's progress to a specific css variable.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {number} [currentProgress] - Progress value.\r\n     */\r\n    _setCssProgress(currentProgress = 0) {\r\n        this.$el.style.setProperty(\r\n            PROGRESS_CSS_VAR,\r\n            currentProgress.toString()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Set the element's progress to the custom event listeners.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {number} [currentProgress] - Progress value.\r\n     */\r\n    _setCustomEventProgress(currentProgress = 0) {\r\n        const customEventName = this.attributes.scrollEventProgress;\r\n\r\n        if (!customEventName) return;\r\n\r\n        const customEvent = new CustomEvent(customEventName, {\r\n            detail: {\r\n                target: this.$el,\r\n                progress: currentProgress,\r\n            },\r\n        });\r\n        window.dispatchEvent(customEvent);\r\n    }\r\n\r\n    /**\r\n     * Get modular modules that can listen the element's progress.\r\n     *\r\n     * @private\r\n     */\r\n    _getProgressModularModules() {\r\n        if (!this.modularInstance) {\r\n            return;\r\n        }\r\n\r\n        const modulesIdNames = Object.keys(this.$el.dataset).filter((key) =>\r\n            key.includes('module')\r\n        );\r\n        const modules: any[] = Object.entries(this.modularInstance.modules);\r\n\r\n        if (!modulesIdNames.length) {\r\n            return;\r\n        }\r\n\r\n        for (const modulesIdName of modulesIdNames) {\r\n            const moduleId = this.$el.dataset[modulesIdName];\r\n\r\n            if (!moduleId) {\r\n                return;\r\n            }\r\n\r\n            for (const module of modules) {\r\n                const [moduleName, moduleObj] = module;\r\n\r\n                if (moduleId in moduleObj) {\r\n                    this.progressModularModules.push({\r\n                        moduleName,\r\n                        moduleId,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function to get scroll call from.\r\n     *\r\n     * @private\r\n     */\r\n    _getScrollCallFrom(): scrollCallFrom {\r\n        const closestIntersectionValue = closestNumber(\r\n            [this.intersection.start, this.intersection.end],\r\n            this.currentScroll\r\n        );\r\n        return this.intersection.start === closestIntersectionValue\r\n            ? 'start'\r\n            : 'end';\r\n    }\r\n\r\n    /**\r\n     * Function to dispatch a custom event or call a modular callback.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {scrollCallWay} way - Enter or leave.\r\n     * @param {scrollCallFrom} from - Start or end.\r\n     */\r\n    _dispatchCall(way: scrollCallWay, from: scrollCallFrom) {\r\n        const callParameters = this.attributes.scrollCall?.split(',');\r\n        const callSelf = this.attributes?.scrollCallSelf;\r\n\r\n        if (callParameters && callParameters.length > 1) {\r\n            // Using Modular.js (https://github.com/modularorg/modularjs)\r\n            const [func, moduleName, moduleId] = callParameters;\r\n            let targetModuleId;\r\n\r\n            // If the module is set on the scroll element\r\n            if (callSelf) {\r\n                targetModuleId = this.$el.dataset[`module${moduleName.trim()}`];\r\n            } else {\r\n                targetModuleId = moduleId;\r\n            }\r\n\r\n            this.modularInstance &&\r\n                this.modularInstance.call(\r\n                    func.trim(),\r\n                    {\r\n                        target: this.$el,\r\n                        way,\r\n                        from,\r\n                    },\r\n                    moduleName.trim(),\r\n                    targetModuleId?.trim()\r\n                );\r\n        } else if (callParameters) {\r\n            // Using CustomEvent API (https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\r\n            const [customEventName] = callParameters;\r\n            const customEvent = new CustomEvent(customEventName, {\r\n                detail: {\r\n                    target: this.$el,\r\n                    way,\r\n                    from,\r\n                },\r\n            });\r\n            window.dispatchEvent(customEvent);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Integrates Lenis with Locomotive's built-in animation system\r\n */\r\n\r\nimport type {\r\n    CoreOptions,\r\n    IModular,\r\n    IScrollElementCallbacksValues,\r\n    scrollOrientation,\r\n} from '../types';\r\nimport IO from './IO';\r\nimport ScrollElement from './ScrollElement';\r\n\r\n/** Defined attributes that need a requestAnimationFrame */\r\nconst ATTRIBUTES_THAT_NEED_RAF = [\r\n    'scrollOffset',\r\n    'scrollPosition',\r\n    'scrollModuleProgress',\r\n    'scrollCssProgress',\r\n    'scrollEventProgress',\r\n    'scrollSpeed',\r\n];\r\n\r\n/** Default root margins */\r\nconst TRIGGER_ROOT_MARGIN = '-1px -1px -1px -1px';\r\nconst RAF_ROOT_MARGIN = '100% 100% 100% 100%'; // Add 100vh top/bottom && 100vw left/right to use a biggest value with data-scroll-speed\r\n\r\nexport default class Core {\r\n    private $scrollContainer!: HTMLElement;\r\n    private modularInstance?: IModular;\r\n    private triggerRootMargin!: string;\r\n    private rafRootMargin!: string;\r\n    private scrollElements!: ScrollElement[];\r\n    private triggeredScrollElements!: ScrollElement[];\r\n    private RAFScrollElements!: ScrollElement[];\r\n    private scrollElementsToUpdate!: ScrollElement[];\r\n    private IOTriggerInstance!: IO;\r\n    private IORafInstance!: IO;\r\n    private scrollOrientation!: scrollOrientation;\r\n\r\n    constructor({\r\n        $el,\r\n        modularInstance,\r\n        triggerRootMargin,\r\n        rafRootMargin,\r\n        scrollOrientation,\r\n    }: CoreOptions) {\r\n        if (!$el) {\r\n            console.error('Please provide a DOM Element as scrollContainer');\r\n            return;\r\n        }\r\n\r\n        // Scroll container\r\n        this.$scrollContainer = $el;\r\n\r\n        // Modular.js\r\n        this.modularInstance = modularInstance;\r\n\r\n        // Scroll Direction\r\n        this.scrollOrientation = scrollOrientation;\r\n\r\n        // IO Margins\r\n        this.triggerRootMargin = triggerRootMargin ?? TRIGGER_ROOT_MARGIN;\r\n        this.rafRootMargin = rafRootMargin ?? RAF_ROOT_MARGIN;\r\n\r\n        // ScrollElements arrays\r\n        this.scrollElements = [];\r\n        this.triggeredScrollElements = [];\r\n        this.RAFScrollElements = [];\r\n        this.scrollElementsToUpdate = [];\r\n\r\n\r\n        // Init\r\n        this._init();\r\n    }\r\n\r\n    /**\r\n     * Lifecyle - Initialize the core.\r\n     *\r\n     * @private\r\n     */\r\n    private _init() {\r\n        const $scrollElements =\r\n            this.$scrollContainer.querySelectorAll('[data-scroll]');\r\n\r\n        const $scrollElementsArr = Array.from($scrollElements) as HTMLElement[]\r\n        this._subscribeScrollElements($scrollElementsArr);\r\n\r\n        // Trigger IO\r\n        this.IOTriggerInstance = new IO({\r\n            scrollElements: [...this.triggeredScrollElements],\r\n            rootMargin: this.triggerRootMargin,\r\n            IORaf: false,\r\n        });\r\n\r\n        // Raf IO\r\n        this.IORafInstance = new IO({\r\n            scrollElements: [...this.RAFScrollElements],\r\n            rootMargin: this.rafRootMargin,\r\n            IORaf: true,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Lifecyle - Destroy core.\r\n     */\r\n    public destroy() {\r\n        this.IOTriggerInstance.destroy();\r\n        this.IORafInstance.destroy();\r\n        this._unsubscribeAllScrollElements();\r\n    }\r\n\r\n    /**\r\n     * Callback - Resize callback.\r\n     */\r\n    onResize({ currentScroll }: IScrollElementCallbacksValues) {\r\n        for (const scrollElement of this.RAFScrollElements) {\r\n            scrollElement.onResize({\r\n                currentScroll,\r\n            } as IScrollElementCallbacksValues);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback - RAF callback.\r\n     */\r\n    onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\r\n        for (const scrollElement of this.scrollElementsToUpdate) {\r\n            scrollElement.onRender({\r\n                currentScroll,\r\n                smooth,\r\n            } as IScrollElementCallbacksValues);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove items from lists of scroll elements and compute all new values.\r\n     *\r\n     * @param {HTMLElement} $oldContainer - HTMLElement that contains data-scroll elements to unsubscribe\r\n     */\r\n    removeScrollElements($oldContainer: HTMLElement) {\r\n        const $scrollElementsToRemove =\r\n            $oldContainer.querySelectorAll('[data-scroll]');\r\n\r\n        if (!$scrollElementsToRemove.length) return;\r\n\r\n        // 1. Remove from IO\r\n        for (let index = 0; index < this.triggeredScrollElements.length; index++) {\r\n            const scrollElement = this.triggeredScrollElements[index];\r\n            const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove) as HTMLElement []\r\n            if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\r\n                this.IOTriggerInstance.unobserve(scrollElement.$el);\r\n                this.triggeredScrollElements.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this.RAFScrollElements.length; index++) {\r\n            const scrollElement = this.RAFScrollElements[index];\r\n            const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove) as HTMLElement []\r\n            if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\r\n                this.IORafInstance.unobserve(scrollElement.$el);\r\n                this.RAFScrollElements.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        // 2. Remove from scrollElementsToUpdate[] and scrollElements[]\r\n        $scrollElementsToRemove.forEach(($scrollElement) => {\r\n            const targetScrollElementToUpdate =\r\n                this.scrollElementsToUpdate.find(\r\n                    (scrollElement) => scrollElement.$el === $scrollElement\r\n                );\r\n            const targetScrollElement = this.scrollElements.find(\r\n                (scrollElement) => scrollElement.$el === $scrollElement\r\n            );\r\n\r\n            if (targetScrollElementToUpdate) {\r\n                this._unsubscribeElementUpdate(targetScrollElementToUpdate);\r\n            }\r\n            if (targetScrollElement) {\r\n                this.scrollElements = this.scrollElements.filter(\r\n                    (scrollElementItem) =>\r\n                        scrollElementItem.id != targetScrollElement.id\r\n                );\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add items to lists of scroll elements and compute all new values.\r\n     *\r\n     * @param {HTMLElement} $newContainer - HTMLElement that contains data-scroll elements to subscribe\r\n     */\r\n    addScrollElements($newContainer: HTMLElement) {\r\n        // 3. Rebuild ScrollElements\r\n        const $scrollElements = $newContainer.querySelectorAll('[data-scroll]');\r\n\r\n        // 4. Get max scrollElement.id\r\n        const ids: number[] = [];\r\n        this.scrollElements.forEach((scrollElement) => {\r\n            ids.push(scrollElement.id);\r\n        });\r\n        const maxID = Math.max(...ids, 0);\r\n        const fromIndex = maxID + 1;\r\n        const $scrollElementsArr = Array.from($scrollElements) as HTMLElement[]\r\n        this._subscribeScrollElements(\r\n            $scrollElementsArr,\r\n            fromIndex,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Create a ScrollElement instance for each elements with\r\n     * `data-scroll` attribute.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {HTMLElement[]} $scrollElements - List of elements that need\r\n     *     to be regarded.\r\n     */\r\n    _subscribeScrollElements(\r\n        $scrollElements: HTMLElement[],\r\n        fromIndex = 0,\r\n        toObserve = false\r\n    ) {\r\n        // For each scroll element create a ScrollElement instance\r\n        for (let index = 0; index < $scrollElements.length; index++) {\r\n            const $scrollElement = $scrollElements[index];\r\n            const needRaf = this._checkRafNeeded($scrollElement);\r\n\r\n            const scrollElementInstance = new ScrollElement({\r\n                $el: $scrollElement,\r\n                id: fromIndex + index,\r\n                scrollOrientation: this.scrollOrientation,\r\n                modularInstance: this.modularInstance,\r\n                subscribeElementUpdateFn:\r\n                    this._subscribeElementUpdate.bind(this),\r\n                unsubscribeElementUpdateFn:\r\n                    this._unsubscribeElementUpdate.bind(this),\r\n                needRaf,\r\n            });\r\n\r\n            // Push to common array\r\n            this.scrollElements.push(scrollElementInstance);\r\n\r\n            // Push to specific array\r\n            if (needRaf) {\r\n                this.RAFScrollElements.push(scrollElementInstance);\r\n\r\n                // Dynamic observe item\r\n                if (toObserve) {\r\n                    this.IORafInstance.scrollElements.push(\r\n                        scrollElementInstance\r\n                    );\r\n                    this.IORafInstance.observe(scrollElementInstance.$el);\r\n                }\r\n            } else {\r\n                this.triggeredScrollElements.push(scrollElementInstance);\r\n\r\n                // Dynamic observe item\r\n                if (toObserve) {\r\n                    this.IOTriggerInstance.scrollElements.push(\r\n                        scrollElementInstance\r\n                    );\r\n                    this.IOTriggerInstance.observe(scrollElementInstance.$el);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all ScrollElement arrays.\r\n     *\r\n     * @private\r\n     */\r\n    _unsubscribeAllScrollElements() {\r\n        this.scrollElements = [];\r\n        this.RAFScrollElements = [];\r\n        this.triggeredScrollElements = [];\r\n        this.scrollElementsToUpdate = [];\r\n    }\r\n\r\n    /**\r\n     * Subscribe ScrollElement instance that needs to be updated.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {ScrollElement} scrollElement - ScrollElement instance inview\r\n     *     that needs to be updated.\r\n     */\r\n    _subscribeElementUpdate(scrollElement: ScrollElement) {\r\n        this.scrollElementsToUpdate.push(scrollElement);\r\n    }\r\n\r\n    /**\r\n     * Unscribe ScrollElement instance that doesn't need to be updated.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {ScrollElement} scrollElement - The updated ScrollElement instance\r\n     *     out of view now.\r\n     */\r\n    _unsubscribeElementUpdate(scrollElement: ScrollElement) {\r\n        this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(\r\n            (scrollElementToUpdate) =>\r\n                scrollElementToUpdate.id != scrollElement.id\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Check if a DOM Element need a requestAnimationFrame to be used.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {HTMLElement} $scrollElement - The element that needs to be checked.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    _checkRafNeeded($scrollElement: HTMLElement) {\r\n        let attributesThatNeedRaf = [...ATTRIBUTES_THAT_NEED_RAF];\r\n\r\n        // Remove utils\r\n        const removeAttribute = (attributeToRemove: string) => {\r\n            attributesThatNeedRaf = attributesThatNeedRaf.filter(\r\n                (attribute) => attribute != attributeToRemove\r\n            );\r\n        };\r\n\r\n        // 1. Check scroll offset values\r\n        if ($scrollElement.dataset.scrollOffset) {\r\n            const value = $scrollElement.dataset.scrollOffset\r\n                .split(',')\r\n                .map((test) => test.replace('%', '').trim())\r\n                .join(',');\r\n            if (value != '0,0') {\r\n                return true;\r\n            } else {\r\n                removeAttribute('scrollOffset');\r\n            }\r\n        } else {\r\n            removeAttribute('scrollOffset');\r\n        }\r\n\r\n        // 2. Check scroll position values\r\n        if ($scrollElement.dataset.scrollPosition) {\r\n            const value = $scrollElement.dataset.scrollPosition.trim();\r\n            if (value != 'top,bottom') {\r\n                return true;\r\n            } else {\r\n                removeAttribute('scrollPosition');\r\n            }\r\n        } else {\r\n            removeAttribute('scrollPosition');\r\n        }\r\n\r\n        // 3. Check scroll speed values\r\n        if (\r\n            $scrollElement.dataset.scrollSpeed &&\r\n            !isNaN(parseFloat($scrollElement.dataset.scrollSpeed))\r\n        ) {\r\n            return true;\r\n        } else {\r\n            removeAttribute('scrollSpeed');\r\n        }\r\n\r\n        // 4. Check others attributes\r\n        for (const attribute of attributesThatNeedRaf) {\r\n            if (attribute in $scrollElement.dataset) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","/**\r\n * Resize Observer\r\n *\r\n * The Resize Observer API provides a performant mechanism by which code can monitor an element for changes to its size,\r\n * with notifications being delivered to the observer each time the size changes.\r\n *\r\n * Features functions to:\r\n *\r\n * - Trigger the resize callback if the specified element's size change.\r\n *\r\n * References:\r\n *\r\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Resize_Observer_API}\r\n */\r\n\r\nimport type { IROOptions } from '../types';\r\n\r\nexport default class RO {\r\n    private $resizeElements: HTMLElement[];\r\n    private isFirstObserve: boolean;\r\n    private observer!: ResizeObserver;\r\n    private resizeCallback: () => void;\r\n\r\n    constructor({ resizeElements, resizeCallback = () => {} }: IROOptions) {\r\n        // Parameters\r\n        this.$resizeElements = resizeElements;\r\n        this.resizeCallback = resizeCallback;\r\n\r\n        // Flags\r\n        this.isFirstObserve = true;\r\n\r\n        // Init\r\n        this._init();\r\n    }\r\n\r\n    /**\r\n     * Lifecyle - Initialize Resize Observer.\r\n     *\r\n     * @private\r\n     */\r\n    private _init() {\r\n        // Callback\r\n        const onResize = (entries: ResizeObserverEntry[]) => {\r\n            !this.isFirstObserve && this.resizeCallback?.();\r\n            this.isFirstObserve = false;\r\n        };\r\n\r\n        // Instance\r\n        this.observer = new ResizeObserver(onResize);\r\n\r\n        // Observe each default elements\r\n        for (const $resizeElement of this.$resizeElements) {\r\n            this.observer.observe($resizeElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lifecyle - Destroy Resize Observer.\r\n     */\r\n    public destroy() {\r\n        this.observer.disconnect();\r\n    }\r\n}\r\n","//@ts-ignore\r\nimport Lenis from 'lenis';\r\nimport Core from './core/Core';\r\nimport RO from './core/RO';\r\nimport type {\r\n    ILenisScrollToOptions,\r\n    ILenisScrollValues,\r\n    ILocomotiveScrollOptions,\r\n    IModular,\r\n    lenisTargetScrollTo,\r\n} from './types';\r\nimport type { LenisOptions } from 'lenis';\r\n\r\n/**\r\n * Locomotive Scroll\r\n *\r\n * Detection of elements in viewport & smooth scrolling with parallax.\r\n *\r\n * Inspired by\r\n * {@link https://github.com/locomotivemtl/locomotive-scroll locomotive-scroll.js}\r\n * and built around\r\n * {@link https://github.com/darkroomengineering/lenis lenis.js}.\r\n */\r\n\r\nexport default class LocomotiveScroll {\r\n    public rafPlaying: boolean;\r\n    public lenisInstance: any;\r\n\r\n    private coreInstance: any;\r\n\r\n    private lenisOptions?: LenisOptions;\r\n    private modularInstance?: IModular;\r\n    private triggerRootMargin?: string;\r\n    private rafRootMargin?: string;\r\n    private rafInstance?: any;\r\n    private autoResize?: boolean;\r\n    private autoStart?: boolean;\r\n    private ROInstance?: RO;\r\n    private scrollCallback?(scrollValues: ILenisScrollValues): void;\r\n    private initCustomTicker?: (render: () => void) => void;\r\n    private destroyCustomTicker?: (render: () => void) => void;\r\n    private _onRenderBind: () => void;\r\n    private _onResizeBind: () => void;\r\n    private _onScrollToBind: (event: MouseEvent) => void;\r\n\r\n    constructor({\r\n        lenisOptions = {},\r\n        modularInstance,\r\n        triggerRootMargin,\r\n        rafRootMargin,\r\n        autoResize = true,\r\n        autoStart = true,\r\n        scrollCallback = () => {},\r\n        initCustomTicker,\r\n        destroyCustomTicker,\r\n    }: ILocomotiveScrollOptions = {}) {\r\n\r\n        for (const [key] of Object.entries(lenisOptions)) {\r\n            if ([\"wrapper\", \"content\", \"infinite\"].includes(key)) {\r\n                console.warn(`Warning: Key \"${key}\" is not possible to edit in Locomotive Scroll.`);\r\n            }\r\n        }\r\n\r\n        // Get arguments\r\n        Object.assign(this, {\r\n            lenisOptions,\r\n            modularInstance,\r\n            triggerRootMargin,\r\n            rafRootMargin,\r\n            autoResize,\r\n            autoStart,\r\n            scrollCallback,\r\n            initCustomTicker,\r\n            destroyCustomTicker,\r\n        });\r\n\r\n\r\n        // Binding\r\n        this._onRenderBind = this._onRender.bind(this);\r\n        this._onScrollToBind = this._onScrollTo.bind(this);\r\n        this._onResizeBind = this._onResize.bind(this);\r\n\r\n        // Data\r\n        this.rafPlaying = false;\r\n\r\n        // Init\r\n        this._init();\r\n    }\r\n\r\n    /**\r\n     * Lifecyle - Initialize instance.\r\n     *\r\n     * @private\r\n     */\r\n    private _init(): void {\r\n        // Create Lenis instance\r\n        this.lenisInstance = new Lenis({\r\n            ...this.lenisOptions,\r\n            wrapper: window,\r\n            content: document.documentElement,\r\n            infinite: false\r\n        });\r\n        this.lenisInstance?.on('scroll', this.scrollCallback);\r\n\r\n        // Add scroll direction attribute on body\r\n        document.documentElement.setAttribute(\r\n            'data-scroll-orientation',\r\n            this.lenisInstance.options.orientation\r\n        );\r\n\r\n        requestAnimationFrame(() => {\r\n            // Create Core Instance\r\n            this.coreInstance = new Core({\r\n                $el: this.lenisInstance.rootElement,\r\n                modularInstance: this.modularInstance,\r\n                triggerRootMargin: this.triggerRootMargin,\r\n                rafRootMargin: this.rafRootMargin,\r\n                scrollOrientation: this.lenisInstance.options.orientation,\r\n            });\r\n\r\n            // Bind Events\r\n            this._bindEvents();\r\n\r\n            // RAF warning\r\n            if (this.initCustomTicker && !this.destroyCustomTicker) {\r\n                console.warn(\r\n                    'initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.'\r\n                );\r\n            } else if (!this.initCustomTicker && this.destroyCustomTicker) {\r\n                console.warn(\r\n                    'destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.'\r\n                );\r\n            }\r\n\r\n            // Start RAF\r\n            this.autoStart && this.start();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Lifecyle - Destroy instance.\r\n     */\r\n    public destroy(): void {\r\n        // Stop raf\r\n        this.stop();\r\n        // Unbind Events\r\n        this._unbindEvents();\r\n        // Destroy Lenis\r\n        this.lenisInstance.destroy();\r\n        // Destroy Core\r\n        this.coreInstance?.destroy();\r\n\r\n        // Ensure a delay before destroying to handle cases of instant destruction\r\n        requestAnimationFrame(() => {\r\n            this.coreInstance?.destroy();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Events - Subscribe events to listen.\r\n     */\r\n    private _bindEvents() {\r\n        this._bindScrollToEvents();\r\n\r\n        if (this.autoResize) {\r\n            if ('ResizeObserver' in window) {\r\n                this.ROInstance = new RO({\r\n                    resizeElements: [document.body],\r\n                    resizeCallback: this._onResizeBind,\r\n                });\r\n            } else {\r\n                (window as any).addEventListener('resize', this._onResizeBind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Events - Unsubscribe listened events.\r\n     */\r\n    private _unbindEvents() {\r\n        this._unbindScrollToEvents();\r\n\r\n        if (this.autoResize) {\r\n            if ('ResizeObserver' in window) {\r\n                this.ROInstance && this.ROInstance.destroy();\r\n            } else {\r\n                (window as any).removeEventListener(\r\n                    'resize',\r\n                    this._onResizeBind\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Events - Subscribe scrollTo events to listen.\r\n     */\r\n    private _bindScrollToEvents($container?: HTMLElement) {\r\n        const $rootContainer = $container\r\n            ? $container\r\n            : this.lenisInstance.rootElement;\r\n        const $scrollToElements =\r\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\r\n\r\n        $scrollToElements?.length &&\r\n            $scrollToElements.forEach(($el: HTMLElement): void => {\r\n                $el.addEventListener('click', this._onScrollToBind, false);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Events - Unsubscribe scrollTo listened events.\r\n     */\r\n    private _unbindScrollToEvents($container?: HTMLElement) {\r\n        const $rootContainer = $container\r\n            ? $container\r\n            : this.lenisInstance.rootElement;\r\n        const $scrollToElements =\r\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\r\n        $scrollToElements?.length &&\r\n            $scrollToElements.forEach(($el: HTMLElement) => {\r\n                $el.removeEventListener('click', this._onScrollToBind, false);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Callback - Resize callback.\r\n     */\r\n    private _onResize() {\r\n        // Waiting the next frame to get the new current scroll value return by Lenis\r\n        requestAnimationFrame(() => {\r\n            this.coreInstance?.onResize({\r\n                currentScroll: this.lenisInstance.scroll,\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Callback - Render callback.\r\n     */\r\n    private _onRender() {\r\n        this.lenisInstance?.raf(Date.now());\r\n\r\n        this.coreInstance?.onRender({\r\n            currentScroll: this.lenisInstance.scroll,\r\n            smooth: this.lenisInstance.options.smoothWheel,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Callback - Scroll To callback.\r\n     */\r\n    private _onScrollTo(event: MouseEvent) {\r\n        event.preventDefault();\r\n        const $target = (event.currentTarget as HTMLElement) ?? null;\r\n        if (!$target) return;\r\n        const target =\r\n            $target.getAttribute('data-scroll-to-href') ||\r\n            $target.getAttribute('href');\r\n        const offset = $target.getAttribute('data-scroll-to-offset') || 0;\r\n        const duration =\r\n            $target.getAttribute('data-scroll-to-duration') ||\r\n            this.lenisInstance.options.duration\r\n        target &&\r\n            this.scrollTo(target, {\r\n                offset: typeof offset === 'string' ? parseInt(offset) : offset,\r\n                duration:\r\n                    typeof duration === 'string'\r\n                        ? parseInt(duration)\r\n                        : duration,\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Start RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n     */\r\n    public start(): void {\r\n        if (this.rafPlaying) {\r\n            return;\r\n        }\r\n\r\n        // Call lenis start method\r\n        this.lenisInstance?.start();\r\n\r\n        this.rafPlaying = true;\r\n        this.initCustomTicker\r\n            ? this.initCustomTicker(this._onRenderBind)\r\n            : this._raf();\r\n    }\r\n\r\n    /**\r\n     * Stop RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n     */\r\n    public stop(): void {\r\n        if (!this.rafPlaying) {\r\n            return;\r\n        }\r\n\r\n        // Call lenis stop method\r\n        this.lenisInstance?.stop();\r\n\r\n        this.rafPlaying = false;\r\n        this.destroyCustomTicker\r\n            ? this.destroyCustomTicker(this._onRenderBind)\r\n            : this.rafInstance && cancelAnimationFrame(this.rafInstance);\r\n    }\r\n\r\n    /**\r\n     * Remove old scroll elements items and rebuild ScrollElements instances.\r\n     */\r\n    public removeScrollElements($oldContainer: HTMLElement): void {\r\n        if (!$oldContainer) {\r\n            console.error('Please provide a DOM Element as $oldContainer');\r\n            return;\r\n        }\r\n\r\n        this._unbindScrollToEvents($oldContainer);\r\n        this.coreInstance?.removeScrollElements($oldContainer);\r\n    }\r\n\r\n    /**\r\n     * Add new scroll elements items and rebuild ScrollElements instances.\r\n     */\r\n    public addScrollElements($newContainer: HTMLElement): void {\r\n        if (!$newContainer) {\r\n            console.error('Please provide a DOM Element as $newContainer');\r\n            return;\r\n        }\r\n\r\n        this.coreInstance?.addScrollElements($newContainer);\r\n        requestAnimationFrame(() => {\r\n            this._bindScrollToEvents($newContainer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Trigger resize callback.\r\n     */\r\n    public resize(): void {\r\n        this._onResizeBind();\r\n    }\r\n\r\n    /**\r\n     * Trigger scroll to callback.\r\n     */\r\n    public scrollTo(\r\n        target: lenisTargetScrollTo,\r\n        options?: ILenisScrollToOptions\r\n    ): void {\r\n        this.lenisInstance?.scrollTo(target, {\r\n            offset: options?.offset,\r\n            lerp: options?.lerp,\r\n            duration: options?.duration,\r\n            immediate: options?.immediate,\r\n            lock: options?.lock,\r\n            force: options?.force,\r\n            easing: options?.easing,\r\n            onComplete: options?.onComplete,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n     *\r\n     * @private\r\n     *\r\n     */\r\n    private _raf() {\r\n        this._onRenderBind();\r\n        this.rafInstance = requestAnimationFrame(() => this._raf());\r\n    }\r\n}\r\n\r\nexport * from './types';\r\n"],"names":["IO","constructor","scrollElements","rootMargin","IORaf","this","observer","_init","IntersectionObserver","entries","forEach","entry","$targetItem","find","item","$el","target","isIntersecting","isAlreadyIntersected","_setInview","_setOutOfView","scrollElement","observe","destroy","disconnect","$scrollElement","unobserve","setInteractivityOn","setInview","setInteractivityOff","setOutOfView","attributes","scrollRepeat","mapRange","inMin","inMax","outMin","outMax","value","closestNumber","array","reduce","prev","curr","Math","abs","ScrollElement","id","modularInstance","subscribeElementUpdateFn","unsubscribeElementUpdateFn","needRaf","scrollOrientation","_this$$el$dataset$scr","_this$$el$dataset$scr2","_this$$el$dataset$scr3","_this$$el$dataset$scr4","_this$$el$dataset$scr5","_this$$el$dataset$scr6","intersection","metrics","currentScroll","translateValue","progress","lastProgress","progressModularModules","isInview","isInteractive","isInFold","isFirstResize","scrollClass","dataset","scrollOffset","scrollPosition","scrollModuleProgress","scrollCssProgress","scrollEventProgress","scrollSpeed","parseFloat","scrollParallaxSideways","scrollParallaxClamp","scrollCall","scrollCallSelf","scrollIgnoreFold","scrollEnableTouchSpeed","start","end","offsetStart","offsetEnd","bcr","window","scrollY","scrollX","_getProgressModularModules","_resize","onResize","onRender","smooth","wSize","innerHeight","innerWidth","_computeProgress","isNaN","max","min","style","transform","classList","add","from","_getScrollCallFrom","_dispatchCall","remove","getBoundingClientRect","_computeMetrics","_computeIntersection","top","left","height","width","metricsSize","offset","split","undefined","trim","scrollPositionStart","scrollPositionEnd","viewportStart","includes","parseInt","replace","viewportEnd","forcedProgress","_setCssProgress","_setCustomEventProgress","modularModules","call","moduleName","moduleId","currentProgress","setProperty","toString","customEventName","customEvent","CustomEvent","detail","dispatchEvent","modulesIdNames","Object","keys","filter","key","modules","length","modulesIdName","module","moduleObj","push","closestIntersectionValue","way","_this$attributes$scro","_this$attributes","callParameters","callSelf","_targetModuleId","func","targetModuleId","ATTRIBUTES_THAT_NEED_RAF","Core","triggerRootMargin","rafRootMargin","$scrollContainer","triggeredScrollElements","RAFScrollElements","scrollElementsToUpdate","IOTriggerInstance","IORafInstance","console","error","$scrollElements","querySelectorAll","$scrollElementsArr","Array","_subscribeScrollElements","_unsubscribeAllScrollElements","removeScrollElements","$oldContainer","$scrollElementsToRemove","index","indexOf","splice","targetScrollElementToUpdate","targetScrollElement","_unsubscribeElementUpdate","scrollElementItem","addScrollElements","$newContainer","ids","fromIndex","toObserve","_checkRafNeeded","scrollElementInstance","_subscribeElementUpdate","bind","scrollElementToUpdate","attributesThatNeedRaf","removeAttribute","attributeToRemove","attribute","map","test","join","RO","resizeElements","resizeCallback","$resizeElements","isFirstObserve","ResizeObserver","_this$resizeCallback","$resizeElement","LocomotiveScroll","lenisOptions","autoResize","autoStart","scrollCallback","initCustomTicker","destroyCustomTicker","rafPlaying","lenisInstance","coreInstance","rafInstance","ROInstance","_onRenderBind","_onResizeBind","_onScrollToBind","warn","assign","_onRender","_onScrollTo","_onResize","_this$lenisInstance","Lenis","_extends","wrapper","content","document","documentElement","infinite","on","setAttribute","options","orientation","requestAnimationFrame","rootElement","_bindEvents","_this$coreInstance","stop","_unbindEvents","_this$coreInstance2","_bindScrollToEvents","body","addEventListener","_unbindScrollToEvents","removeEventListener","$container","$rootContainer","$scrollToElements","_this$coreInstance3","scroll","_this$lenisInstance2","_this$coreInstance4","raf","Date","now","smoothWheel","event","_event$currentTarget","preventDefault","$target","currentTarget","getAttribute","duration","scrollTo","_this$lenisInstance3","_raf","_this$lenisInstance4","cancelAnimationFrame","_this$coreInstance5","_this$coreInstance6","resize","_this$lenisInstance5","lerp","immediate","lock","force","easing","onComplete"],"mappings":"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"}